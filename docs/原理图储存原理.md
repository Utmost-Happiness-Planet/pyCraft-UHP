## 原理图储存原理（Litematic）

利用两个结构储存所有方块的信息：

1. List<方块状态对象> —— 有序保存该原理图涉及到的所有方块的状态
2. Array\<Long> —— 一个长整型数组



## List<方块状态对象>

简单介绍一下方块状态对象，它包含：

- 方块名称
- 方块所处状态（如活塞体是否推出、朝哪个方向推出）

> Tips：同一方块的不同状态所对应的方块状态对象不同
>
> 如：点亮的红石火把和熄灭的红石火把是两个方块状态对象

该列表储存了本原理图涉及到的所有方块状态对象，且为每个方块状态对象从 0 自增分配了索引。

> Tips：该列表的 0 号元素永远是空气，无论你的原理图是否包含空气方块

----

举个例子：

你的原理图有 3 个橡木木板、 2 个点亮的红石火把、 1 个熄灭的红石火把。

你将获得一个长度为 4 的 List ，其中包含空气对象、橡木木板对象、红石火把（点亮）对象、红石火把（熄灭）对象。

该列表是有序的，即每个元素有对应的索引，其中空气对象的索引必然是 0 。



## Array\<Long>

该长整型数组解决一件事：记录每个坐标对应的方块状态对象的索引值。

即它会告诉你，某个坐标的方块状态对象索引值是多少，你拿着索引值就可以通过上文的 List 找到放在该坐标的方块了。

---
先假设数组中只有一个元素。

如果你把它看作一个数字，你就永远不能理解它是怎么储存信息的了。

事实上，它是一张比特表。

> 如果你不知道什么是比特表，请看下面的例子：
>
> 假设我有一个共三格方块的原理图，我把它的每一个坐标编上序号，1 号位置是橡木，2 号位置是玻璃，3 号位置也是玻璃。
>
> 假设 List 中，空气的索引值为 0 ，橡木的索引值为 1，玻璃的索引值为 2 。
>
> 如何保存这些信息呢，显而易见有一个方法：
>
> 1. 创建一个整型数组 arr
> 2. arr[0] = 1; arr[1] = 2; arr[2] = 2
> 3. 保存该数组
>
> 你想知道 1 号位置是什么方块，只需要去查 arr[0] = ?，得到的值就是该方块状态的索引值。
>
> 这样事实上已经解决了问题，但是有一点小瑕疵：太浪费空间了。
>
> 一个整型占 4 字节，你却永远只用它存 0 ~ 2，事实上保存 0 ~ 2 用两个位就足够了。
>
> 所以你完全可以选择保存一串二进制：01 10 10
>
> 把该二进制转化为十进制长整型 => 26，这就是你得到的 Long 值。

Litematic 用的就是这个原理。

首先，它会把 x，y，z 三维坐标映射到一维空间中：

```python
def getIndex(self, x: int, y: int, z: int):
        return (y * self.sizeLayer) + z * self.sizeX + x
```

其中`self.sizeLayer` = 原理图的长 x 原理图的宽、`self.sizeX` = 原理图的长。

原理很简单，想象你把一个二维数组每行首尾相接成一个一维数组。同样的方法运用到三维空间里即可。

其次，它会计算出存一个方块状态对象的索引最多需要多少位。这取决于 List 的长度。

然后它就开始构造这个 Array\<Long> 了，如果你的数据量很大，一个长整型存不完，他就会使用多个长整型首尾相接。



## 例子

![pic](https://github.com/Utmost-Happiness-Planet/pyCraft-UHP/blob/master/docs/assets/Litematic.png)

它的数据结构如下：

1. List：[0：空气，1：红色，2：青绿色，3：黄色，4：亮蓝，5：白色，6：黑色]
2. Long：12277969

查询步骤：

1. 将 Long 转换为二进制：101110110101100011010001

2. 因为 List 长度为 7，需要三位存一个索引，把 Long 分割为：[101，110，110，101，100，011，010，001]，记为 BitArray
   - 如果不能整除需要在前面补零再分割
3. 假设我们要查询（1， 1， 0）坐标的方块，即图中黄色方块。结果为 `List[BitArray[getIndex(1, 1, 0)]]`，正是黄色方块。

